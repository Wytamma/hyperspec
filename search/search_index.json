{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"hyperspec","text":"<p>Table of Contents</p> <ul> <li>Installation</li> <li>License</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install git+https://github.com/smutch/hyperspec.git\n</code></pre>"},{"location":"#license","title":"License","text":"<p><code>hyperspec</code> is distributed under the terms of the MIT license.</p>"},{"location":"reference/io/","title":"Io","text":""},{"location":"reference/io/#hyperspec.io.crop","title":"<code>crop(arr, bounds)</code>","text":"<p>Crops a 2D array or DataArray.</p> <p>Parameters:</p> Name Type Description Default <code>arr</code> <code>TCropArr</code> <p>The array or DataArray to crop.</p> required <code>bounds</code> <code>npt.NDArray[np.int_]</code> <p>The bounds of the crop.</p> required <p>Returns:</p> Name Type Description <code>TCropArr</code> <code>TCropArr</code> <p>The cropped array or DataArray.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; arr = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n&gt;&gt;&gt; bounds = np.array([[0, 1], [1, 2]])\n&gt;&gt;&gt; crop(arr, bounds)\narray([[2, 3],\n       [5, 6]])\n</code></pre> Source code in <code>hyperspec/io.py</code> <pre><code>def crop(arr: TCropArr, bounds: npt.NDArray[np.int_]) -&gt; TCropArr:\n\"\"\"\n    Crops a 2D array or DataArray.\n    Args:\n      arr (TCropArr): The array or DataArray to crop.\n      bounds (npt.NDArray[np.int_]): The bounds of the crop.\n    Returns:\n      TCropArr: The cropped array or DataArray.\n    Examples:\n      &gt;&gt;&gt; arr = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n      &gt;&gt;&gt; bounds = np.array([[0, 1], [1, 2]])\n      &gt;&gt;&gt; crop(arr, bounds)\n      array([[2, 3],\n             [5, 6]])\n    \"\"\"\n    xmin, xmax = np.sort(bounds, axis=0)[:, 0][[0, -1]]\n    ymin, ymax = np.sort(bounds, axis=1)[:, 1][[0, -1]]\n    return arr[ymin:ymax, xmin:xmax]\n</code></pre>"},{"location":"reference/io/#hyperspec.io.read_cube","title":"<code>read_cube(path, bounds, smooth=0.0)</code>","text":"<p>Reads a BIL hypercube and optionally crops it.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>The path to the BIL hypercube.</p> required <code>bounds</code> <code>npt.NDArray | None</code> <p>The bounds of the crop.</p> required <code>smooth</code> <code>float</code> <p>The sigma of the Gaussian filter to apply.</p> <code>0.0</code> <p>Returns:</p> Type Description <code>xr.DataArray</code> <p>xr.DataArray: The hypercube.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; cube = read_cube(Path(\"/path/to/hypercube.bil\"), bounds=np.array([[0, 1], [1, 2]]), smooth=2.0)\n&gt;&gt;&gt; cube\n&lt;xarray.DataArray (y: 2, x: 2, band: 100)&gt;\narray([[[0.0020, 0.0020, ..., 0.0020],\n        [0.0020, 0.0020, ..., 0.0020]],\n\n       [[0.0020, 0.0020, ..., 0.0020],\n        [0.0020, 0.0020, ..., 0.0020]]])\nCoordinates:\n  * y        (y) int64 0 1\n  * x        (x) int64 0 1\n  * band     (band) float64 0.4999 0.5999 ... 2.4 2.5\n</code></pre> Source code in <code>hyperspec/io.py</code> <pre><code>def read_cube(path: Path, bounds: npt.NDArray | None, smooth: float = 0.0) -&gt; xr.DataArray:\n\"\"\"\n    Reads a BIL hypercube and optionally crops it.\n    Args:\n      path (Path): The path to the BIL hypercube.\n      bounds (npt.NDArray | None): The bounds of the crop.\n      smooth (float): The sigma of the Gaussian filter to apply.\n    Returns:\n      xr.DataArray: The hypercube.\n    Examples:\n      &gt;&gt;&gt; cube = read_cube(Path(\"/path/to/hypercube.bil\"), bounds=np.array([[0, 1], [1, 2]]), smooth=2.0)\n      &gt;&gt;&gt; cube\n      &lt;xarray.DataArray (y: 2, x: 2, band: 100)&gt;\n      array([[[0.0020, 0.0020, ..., 0.0020],\n              [0.0020, 0.0020, ..., 0.0020]],\n      &lt;BLANKLINE&gt;\n             [[0.0020, 0.0020, ..., 0.0020],\n              [0.0020, 0.0020, ..., 0.0020]]])\n      Coordinates:\n        * y        (y) int64 0 1\n        * x        (x) int64 0 1\n        * band     (band) float64 0.4999 0.5999 ... 2.4 2.5\n    \"\"\"\n    raw = spectral.open_image(str(path))\n    if type(raw) != spectral.io.bilfile.BilFile:\n        _err = f\"Expected BIL hypercube, got {type(raw)}\"\n        raise ValueError(_err)\n\n    data = np.rot90(raw.asarray(), -1)\n    if smooth &gt; 0.0:\n        data = gaussian_filter(data, sigma=smooth)\n\n    cube = xr.DataArray(\n        data,\n        dims=(\"y\", \"x\", \"band\"),\n        coords={\n            \"x\": np.arange(raw.ncols),\n            \"y\": np.arange(raw.nrows),\n            \"band\": raw.bands.centers,\n        },\n    )\n\n    if bounds is not None:\n        cube = crop(cube, bounds)\n    return cube\n</code></pre>"},{"location":"reference/io/#hyperspec.io.read_preview","title":"<code>read_preview(cube_path, bounds=None, *, smooth=0.0, greyscale=False)</code>","text":"<p>Reads a preview image and optionally crops it.</p> <p>Parameters:</p> Name Type Description Default <code>cube_path</code> <code>Path</code> <p>The path to the BIL hypercube.</p> required <code>bounds</code> <code>npt.NDArray[np.int_] | None</code> <p>The bounds of the crop.</p> <code>None</code> <code>smooth</code> <code>float</code> <p>The sigma of the Gaussian filter to apply.</p> <code>0.0</code> <code>greyscale</code> <code>bool</code> <p>Whether to convert the image to greyscale.</p> <code>False</code> <p>Returns:</p> Type Description <code>npt.NDArray</code> <p>npt.NDArray: The preview image.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; preview = read_preview(Path(\"/path/to/hypercube.bil\"), bounds=np.array([[0, 1], [1, 2]]), smooth=2.0, greyscale=True)\n&gt;&gt;&gt; preview\narray([[0.0020, 0.0020],\n       [0.0020, 0.0020]], dtype=float32)\n</code></pre> Source code in <code>hyperspec/io.py</code> <pre><code>def read_preview(\n    cube_path: Path, bounds: npt.NDArray[np.int_] | None = None, *, smooth: float = 0.0, greyscale: bool = False\n) -&gt; npt.NDArray:\n\"\"\"\n    Reads a preview image and optionally crops it.\n    Args:\n      cube_path (Path): The path to the BIL hypercube.\n      bounds (npt.NDArray[np.int_] | None): The bounds of the crop.\n      smooth (float): The sigma of the Gaussian filter to apply.\n      greyscale (bool): Whether to convert the image to greyscale.\n    Returns:\n      npt.NDArray: The preview image.\n    Examples:\n      &gt;&gt;&gt; preview = read_preview(Path(\"/path/to/hypercube.bil\"), bounds=np.array([[0, 1], [1, 2]]), smooth=2.0, greyscale=True)\n      &gt;&gt;&gt; preview\n      array([[0.0020, 0.0020],\n             [0.0020, 0.0020]], dtype=float32)\n    \"\"\"\n    ident = cube_path.name.removeprefix(\"REFLECTANCE_\").removesuffix(\".hdr\")\n    path = cube_path.parents[1] / f\"{ident}.png\"\n    if not path.exists():\n        _err = f\"Preview image not found at {path}\"\n        raise FileNotFoundError(_err)\n    preview = cv2.imread(str(path), cv2.IMREAD_COLOR)\n    if greyscale:\n        preview = cv2.cvtColor(preview, cv2.COLOR_BGR2GRAY)\n    if smooth &gt; 0.0:\n        preview = gaussian_filter(preview, sigma=smooth)\n    if bounds is not None:\n        preview = crop(preview, bounds)\n    return preview\n</code></pre>"},{"location":"reference/registration/","title":"Registration","text":""},{"location":"reference/registration/#hyperspec.registration.register","title":"<code>register(dst_preview, dst_cube, src_preview, src_cube, *, orb_create_kwargs=None, flann_index_kwargs=None, flann_search_kwargs=None)</code>","text":"<p>Registers the source cube to the destination cube.</p> <p>Parameters:</p> Name Type Description Default <code>dst_preview</code> <code>npt.NDArray</code> <p>Preview of the destination cube.</p> required <code>dst_cube</code> <code>xr.DataArray</code> <p>Destination cube.</p> required <code>src_preview</code> <code>npt.NDArray</code> <p>Preview of the source cube.</p> required <code>src_cube</code> <code>xr.DataArray</code> <p>Source cube.</p> required <code>orb_create_kwargs</code> <code>dict[str, Any] | None</code> <p>Keyword arguments for ORB creation.</p> <code>None</code> <code>flann_index_kwargs</code> <code>dict[str, Any] | None</code> <p>Keyword arguments for FLANN index.</p> <code>None</code> <code>flann_search_kwargs</code> <code>dict[str, Any] | None</code> <p>Keyword arguments for FLANN search.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[xr.DataArray | None, npt.NDArray | None, npt.NDArray]</code> <p>tuple[xr.DataArray | None, npt.NDArray | None, npt.NDArray]: The registered cube, the registered preview, and the matched keypoints visualization.</p> Side Effects <p>None</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; register(dst_preview, dst_cube, src_preview, src_cube, orb_create_kwargs={\"nfeatures\": 1000}, flann_index_kwargs={\"algorithm\": 5})\n(xr.DataArray, npt.NDArray, npt.NDArray)\n</code></pre> Source code in <code>hyperspec/registration.py</code> <pre><code>def register(\n    dst_preview: npt.NDArray,\n    dst_cube: xr.DataArray,\n    src_preview: npt.NDArray,\n    src_cube: xr.DataArray,\n    *,\n    orb_create_kwargs: dict[str, Any] | None = None,\n    flann_index_kwargs: dict[str, Any] | None = None,\n    flann_search_kwargs: dict[str, Any] | None = None,\n) -&gt; tuple[xr.DataArray | None, npt.NDArray | None, npt.NDArray]:\n\"\"\"\n    Registers the source cube to the destination cube.\n    Args:\n      dst_preview (npt.NDArray): Preview of the destination cube.\n      dst_cube (xr.DataArray): Destination cube.\n      src_preview (npt.NDArray): Preview of the source cube.\n      src_cube (xr.DataArray): Source cube.\n      orb_create_kwargs (dict[str, Any] | None): Keyword arguments for ORB creation.\n      flann_index_kwargs (dict[str, Any] | None): Keyword arguments for FLANN index.\n      flann_search_kwargs (dict[str, Any] | None): Keyword arguments for FLANN search.\n    Returns:\n      tuple[xr.DataArray | None, npt.NDArray | None, npt.NDArray]: The registered cube, the registered preview, and the matched keypoints visualization.\n    Side Effects:\n      None\n    Examples:\n      &gt;&gt;&gt; register(dst_preview, dst_cube, src_preview, src_cube, orb_create_kwargs={\"nfeatures\": 1000}, flann_index_kwargs={\"algorithm\": 5})\n      (xr.DataArray, npt.NDArray, npt.NDArray)\n    \"\"\"\n    _orb_create_kwargs = {\"nfeatures\": 10_000, \"scaleFactor\": 1.2, \"scoreType\": cv2.ORB_HARRIS_SCORE}\n    _orb_create_kwargs.update(orb_create_kwargs or {})\n    orb = cv2.ORB_create(**_orb_create_kwargs)\n\n    keypoints_src, descriptors_src = orb.detectAndCompute(src_preview, None)\n    keypoints_dst, descriptors_dst = orb.detectAndCompute(dst_preview, None)\n\n    _flann_index_kwargs = {\"algorithm\": 6, \"table_number\": 6, \"key_size\": 10, \"multi_probe_level\": 2}\n    _flann_index_kwargs.update(flann_index_kwargs or {})\n    _flann_search_kwargs = {\"checks\": 50}\n    _flann_search_kwargs.update(flann_search_kwargs or {})\n    matcher = cv2.FlannBasedMatcher(_flann_index_kwargs, _flann_search_kwargs)\n\n    matches = [m for m, n in matcher.knnMatch(descriptors_src, descriptors_dst, k=2) if m.distance &lt; 0.7 * n.distance]\n\n    matched_vis = cv2.drawMatches(src_preview, keypoints_src, dst_preview, keypoints_dst, matches, None)\n    matched_vis = imutils.resize(matched_vis, width=1_000)\n\n    try:\n        pts_src = np.array([keypoints_src[m.queryIdx].pt for m in matches]).reshape(-1, 1, 2)\n        pts_dst = np.array([keypoints_dst[m.trainIdx].pt for m in matches]).reshape(-1, 1, 2)\n        homog, _ = cv2.findHomography(pts_src, pts_dst, method=cv2.RANSAC, ransacReprojThreshold=5.0)\n\n        result_preview = cv2.warpPerspective(src_preview, homog, src_preview.shape[:2][::-1])\n\n        result = xr.zeros_like(dst_cube)\n        for band in result.band:\n            result.loc[..., band] = cv2.warpPerspective(\n                src_cube.sel(band=band).values, homog, dst_preview.shape[:2][::-1], borderValue=-999\n            )\n        result = xr.DataArray(result, dims=dst_cube.dims, coords=dst_cube.coords)\n    except cv2.error as err:\n        warn(err.msg, stacklevel=2)\n        return None, None, matched_vis\n\n    return result, result_preview, matched_vis\n</code></pre>"},{"location":"reference/stats/","title":"Stats","text":""},{"location":"reference/stats/#hyperspec.stats.pca","title":"<code>pca(cube, n_components=3)</code>","text":"<p>Computes principal components of a cube.</p> <p>Parameters:</p> Name Type Description Default <code>cube</code> <code>xr.DataArray</code> <p>The cube to compute principal components of.</p> required <code>n_components</code> <code>int</code> <p>The number of components to compute.</p> <code>3</code> <p>Returns:</p> Type Description <code>xr.Dataset</code> <p>xr.Dataset: A dataset containing the principal components.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; cube = xr.DataArray(np.random.rand(3, 3, 3))\n&gt;&gt;&gt; pca(cube, n_components=2)\n&lt;xarray.Dataset&gt;\nDimensions:  (band: 2)\nCoordinates:\n  * band     (band) int64 0 1\nData variables:\n    0        (band) float64 0.541 0.8\n    1        (band) float64 0.8 0.541\n</code></pre> Source code in <code>hyperspec/stats.py</code> <pre><code>def pca(cube: xr.DataArray, n_components: int = 3) -&gt; xr.Dataset:\n\"\"\"\n    Computes principal components of a cube.\n    Args:\n      cube (xr.DataArray): The cube to compute principal components of.\n      n_components (int): The number of components to compute.\n    Returns:\n      xr.Dataset: A dataset containing the principal components.\n    Examples:\n      &gt;&gt;&gt; cube = xr.DataArray(np.random.rand(3, 3, 3))\n      &gt;&gt;&gt; pca(cube, n_components=2)\n      &lt;xarray.Dataset&gt;\n      Dimensions:  (band: 2)\n      Coordinates:\n        * band     (band) int64 0 1\n      Data variables:\n          0        (band) float64 0.541 0.8\n          1        (band) float64 0.8 0.541\n    \"\"\"\n    model = decomp.PCA(n_components=n_components)\n    bands = cube.band.values\n    X = (  # noqa: N806  &lt;- sklearn norm\n        cube.dropna(\"x\", how=\"all\").dropna(\"y\", how=\"all\").values.reshape((-1, bands.size))\n    )\n    model.fit_transform(X)\n    components = xr.Dataset(\n        {str(ii): ((\"band\",), component) for ii, component in enumerate(model.components_)},\n        coords={\"band\": bands},\n    )\n    return components\n</code></pre>"},{"location":"reference/stats/#hyperspec.stats.pixelwise_cosine_similarity","title":"<code>pixelwise_cosine_similarity(cube1, cube2)</code>","text":"<p>Computes the cosine similarity between two cubes.</p> <p>Parameters:</p> Name Type Description Default <code>cube1</code> <code>npt.NDArray[np.float_]</code> <p>The first cube.</p> required <code>cube2</code> <code>npt.NDArray[np.float_]</code> <p>The second cube.</p> required <p>Returns:</p> Type Description <code>npt.NDArray[np.float_]</code> <p>npt.NDArray[np.float_]: An array of shape (N,) containing the cosine similarity between each pair of vectors.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If cube1 and cube2 have different shapes.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; cube1 = np.random.rand(3, 3, 3)\n&gt;&gt;&gt; cube2 = np.random.rand(3, 3, 3)\n&gt;&gt;&gt; pixelwise_cosine_similarity(cube1, cube2)\narray([[0.988, 0.988, 0.988],\n       [0.988, 0.988, 0.988],\n       [0.988, 0.988, 0.988]])\n</code></pre> Source code in <code>hyperspec/stats.py</code> <pre><code>def pixelwise_cosine_similarity(cube1: npt.NDArray[np.float_], cube2: npt.NDArray[np.float_]) -&gt; npt.NDArray[np.float_]:\n\"\"\"\n    Computes the cosine similarity between two cubes.\n    Args:\n      cube1 (npt.NDArray[np.float_]): The first cube.\n      cube2 (npt.NDArray[np.float_]): The second cube.\n    Returns:\n      npt.NDArray[np.float_]: An array of shape (N,) containing the cosine similarity between each pair of vectors.\n    Raises:\n      ValueError: If cube1 and cube2 have different shapes.\n    Examples:\n      &gt;&gt;&gt; cube1 = np.random.rand(3, 3, 3)\n      &gt;&gt;&gt; cube2 = np.random.rand(3, 3, 3)\n      &gt;&gt;&gt; pixelwise_cosine_similarity(cube1, cube2)\n      array([[0.988, 0.988, 0.988],\n             [0.988, 0.988, 0.988],\n             [0.988, 0.988, 0.988]])\n    \"\"\"\n    arr1 = cube1.reshape((-1, cube1.shape[-1]))\n    arr2 = cube2.reshape((-1, cube2.shape[-1]))\n\n    if arr1.shape != arr2.shape:\n        _err = f\"cube1 and cube2 must have the same shape, but got {arr1.shape} and {arr2.shape}\"\n        raise ValueError(_err)\n\n    return _cosine_similarity(arr1, arr2).reshape(cube1.shape[:-1])\n</code></pre>"}]}